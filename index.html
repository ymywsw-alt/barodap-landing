<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>바로답</title>
</head>

<body style="font-family:system-ui; max-width:720px; margin:0 auto; padding:16px;">
  <h1 style="margin:8px 0 0 0;">바로답</h1>
  <p style="margin:8px 0 16px 0; color:#333;">
    이해 안 되는 걸 보내면, 지금 할 한 가지를 바로 알려줍니다.
  </p>

  <h3 style="margin:0 0 8px 0;">문장을 그대로 붙여넣으세요</h3>

  <!-- 입력창 -->
  <textarea id="text" rows="4"
    placeholder="예) ‘납부 기한이 경과되었습니다’ 이게 무슨 뜻이지?"
    style="width:100%; box-sizing:border-box; padding:12px; border:1px solid #ddd; border-radius:12px; font-size:16px;"></textarea>

  <!-- 사진 버튼 (클릭 즉시 iOS 선택창) -->
  <div style="margin-top:10px; display:flex; gap:10px; align-items:center;">
    <input id="img" type="file" accept="image/*" style="display:none" />
    <button id="photo" type="button"
      style="flex:1; padding:12px; border:1px solid #ddd; border-radius:12px; font-size:16px; font-weight:700; cursor:pointer;">
      사진으로 바로답
    </button>
  </div>

  <!-- 단일 버튼(바로답 ↔ 새 문장 넣기) -->
  <button id="go" type="button"
    style="margin-top:12px; width:100%; padding:12px; border:0; border-radius:12px; font-size:16px; font-weight:800; cursor:pointer; background:#111; color:#fff;">
    바로답
  </button>

  <!-- 결과 -->
  <div id="out"
    style="margin-top:12px; padding:14px; border:1px solid #eee; border-radius:12px; background:#fafafa; white-space:pre-wrap; font-size:16px; line-height:1.55;">
정의: 입력이 비어 있습니다.
중요도: 판단할 정보가 없습니다.
행동: 이해 안 되는 문장을 그대로 1~2줄 붙여넣으세요.
  </div>

<script>
  const $text = document.getElementById('text');
  const $img  = document.getElementById('img');
  const $photo = document.getElementById('photo');
  const $go   = document.getElementById('go');
  const $out  = document.getElementById('out');

  let mode = "answer"; // answer | reset

  function setMode(next) {
    mode = next;
    if (mode === "answer") {
      $go.textContent = "바로답";
    } else {
      $go.textContent = "새 문장 넣기";
    }
  }

  function showResult(defn, importance, action) {
    $out.textContent =
      "정의: " + defn + "\n" +
      "중요도: " + importance + "\n" +
      "행동: " + action;
  }

  function normalizeText(s) {
    return (s || "").replace(/\s+/g, " ").trim();
  }

  // 사진 버튼: confirm 없이 즉시 iOS 선택창(사진 보관함/사진 찍기/파일 선택)
  $photo.addEventListener("click", () => {
    $img.click();
  });

  // 사진 선택 후 OCR 호출
  $img.addEventListener("change", async () => {
    const file = $img.files && $img.files[0];
    if (!file) return;

    showResult("이미지를 읽는 중입니다.", "잠시만 기다려주세요.", "완료되면 자동으로 결과가 표시됩니다.");

    try {
      const base64 = await fileToBase64(file);

      const resp = await fetch("/api/ocr", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ imageBase64: base64 })
      });

      const data = await resp.json().catch(() => ({}));

      if (!resp.ok || !data || data.ok === false) {
        showResult("서버 오류가 발생했습니다.",
          "일시적 오류일 수 있습니다.",
          "잠시 후 다시 시도해주세요.");
        return;
      }

      const extracted = (data.text || "").trim();

      if (!extracted) {
        showResult("글자를 읽지 못했습니다.",
          "다시 촬영/선택이 필요합니다.",
          "글자가 크게 보이게, 흔들림 없이 다시 찍어주세요.");
        return;
      }

      // ✅ 중요한 UX: 사진 OCR 결과는 "덮어쓰기" (누적 금지)
      $text.value = extracted;

      // OCR 결과가 들어오면 바로 답 모드로
      setMode("answer");

      // 자동으로 바로답 실행
      await runBarodap();

    } catch (e) {
      showResult("이미지 처리 중 오류가 발생했습니다.",
        "파일 형식/네트워크 문제일 수 있습니다.",
        "다른 방법으로 다시 시도해주세요.");
    } finally {
      // 같은 사진 재선택을 위해 input 초기화
      $img.value = "";
    }
  });

  // 단일 버튼 동작
  $go.addEventListener("click", async () => {
    if (mode === "reset") {
      $text.value = "";
      showResult("정의: 입력이 비어 있습니다.",
        "중요도: 판단할 정보가 없습니다.",
        "행동: 이해 안 되는 문장을 그대로 1~2줄 붙여넣으세요.");
      setMode("answer");
      $text.focus();
      return;
    }
    await runBarodap();
  });

  async function runBarodap() {
    const t = normalizeText($text.value);

    if (!t) {
      showResult("입력이 비어 있습니다.",
        "판단할 정보가 없습니다.",
        "이해 안 되는 문장을 그대로 1~2줄 붙여넣으세요.");
      setMode("answer");
      return;
    }

    // 여기서는 “결정 로직”을 간단히 두고,
    // 실제 고도화는 다음 단계에서 4가지 결론 타입 강제/분기룰로 진행
    const decision = decide(t);

    showResult(decision.defn, decision.importance, decision.action);

    // 답을 보여준 상태에서는 버튼을 "새 문장 넣기"로 바꿔서
    // 시니어가 다음 행동을 고민하지 않게 함
    setMode("reset");
  }

  function decide(t) {
    // 최소한의 안전한 기본 로직(지금은 안정성 우선)
    // 다음 단계에서 4결론 타입 강제 + 도메인 분기(문자/고지서/계약/안내 등)로 확장
    const hasMoney = /원|결제|취소|환불|납부|연체|세금|국세청|카드|계좌|송금|청구/.test(t);
    const hasUrgent = /오늘|내일|즉시|긴급|연락|마감|기한|연체/.test(t);
    const hasRequest = /요청|제출|확인|동의|인증|접속|로그인|클릭/.test(t);

    if (hasMoney && hasUrgent) {
      return {
        defn: "금전/기한 관련 안내로 보입니다.",
        importance: "잘못 대응하면 불이익(연체/수수료/오해)이 생길 수 있습니다.",
        action: "보낸 곳(기관/회사) 이름과 ‘무엇을 하라고 하는지’ 1줄만 추가로 붙여넣으세요."
      };
    }
    if (hasMoney) {
      return {
        defn: "결제/납부/취소 등 금전 관련 문장일 가능성이 큽니다.",
        importance: "오해하면 손해로 이어질 수 있어 확인이 필요합니다.",
        action: "문장에 나온 날짜/금액/기관명을 확인하고, ‘무엇을 하라는지’가 없으면 추가 문구를 더 붙여넣으세요."
      };
    }
    if (hasRequest || hasUrgent) {
      return {
        defn: "무언가를 확인/진행하라는 안내로 보입니다.",
        importance: "기한이 있으면 놓치면 불편이 생길 수 있습니다.",
        action: "문장에 나온 ‘기한’과 ‘요구사항(무엇을 하라는지)’만 체크해서 그대로 실행하면 됩니다."
      };
    }
    return {
      defn: "의미가 확실하지 않은 문장입니다.",
      importance: "섣불리 판단하면 오해가 생길 수 있습니다.",
      action: "발신처(기관/회사) 이름과 ‘무엇을 요구하는지’가 보이게 문장을 더 붙여넣으세요."
    };
  }

  function fileToBase64(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onerror = () => reject(new Error("File read error"));
      reader.onload = () => {
        const s = String(reader.result || "");
        // data:image/...;base64,XXXX -> XXXX
        const idx = s.indexOf("base64,");
        resolve(idx >= 0 ? s.slice(idx + 7) : s);
      };
      reader.readAsDataURL(file);
    });
  }
</script>
</body>
</html>
