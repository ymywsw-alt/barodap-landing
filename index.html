<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>바로답</title>
</head>

<body style="font-family:system-ui; max-width:720px; margin:0 auto; padding:16px;">
  <h1 style="margin:0 0 10px 0;">바로답</h1>
  <p style="margin:0 0 18px 0; color:#444;">
    이해 안 되는 걸 보내면, 지금 할 한 가지를 바로 알려줍니다.
  </p>

  <h3 style="margin:0 0 8px 0;">문장을 그대로 붙여넣으세요</h3>

  <textarea id="text" rows="4"
    placeholder="예) ‘납부 기한이 경과되었습니다’ 이게 무슨 뜻이지?"
    style="width:100%; padding:12px; border:1px solid #ddd; border-radius:12px; font-size:16px; line-height:1.5;"></textarea>

  <!-- 사진 업로드(촬영/보관함/파일 선택) -->
  <div style="margin-top:10px; display:flex; gap:10px; align-items:center;">
    <input id="img" type="file" accept="image/*" style="display:none" />
    <button id="photo" type="button"
      style="flex:1; padding:12px; border:1px solid #ddd; border-radius:12px; font-size:16px; font-weight:700; cursor:pointer;">
      사진으로 바로답
    </button>
  </div>

  <!-- 단일 버튼: (바로답 ↔ 새 문장 넣기) -->
  <button id="go" type="button"
    style="margin-top:12px; width:100%; padding:14px; border:0; border-radius:12px; font-size:16px; font-weight:800; cursor:pointer; background:#111; color:#fff;">
    새 문장 넣기
  </button>

  <div id="out"
    style="margin-top:14px; border:1px solid #eee; border-radius:14px; padding:14px; background:#fafafa; white-space:pre-wrap; line-height:1.6;">
정의: 입력이 비어 있습니다.
중요도: 판단할 정보가 없습니다.
행동: 이해 안 되는 문장을 그대로 1~2줄 붙여넣으세요.
  </div>

<script>
  const $text = document.getElementById('text');
  const $img  = document.getElementById('img');
  const $photo= document.getElementById('photo');
  const $go   = document.getElementById('go');
  const $out  = document.getElementById('out');

  let state = "READY"; // READY(입력 대기) / DONE(답변 완료)

  function setState(next) {
    state = next;
    if (state === "READY") {
      $go.textContent = "바로답";
      $go.style.background = "#111";
      $go.style.color = "#fff";
    } else {
      $go.textContent = "새 문장 넣기";
      $go.style.background = "#eee";
      $go.style.color = "#111";
    }
  }

  // 초기 상태: 바로답 버튼이 보이도록
  setState("READY");

  function normalize(s) {
    return (s || "").replace(/\s+/g, " ").trim();
  }

  function hasAny(s, arr) {
    return arr.some(k => s.includes(k));
  }

  // ✅ 핵심: "완료/처리됨/취소됨" 등 안심형 상태 알림 분기
  function isCompletionNotice(t) {
    // 주의: "취소"는 행동 요구(예약 취소 요청 등)도 있어서,
    // "취소되었습니다/취소됨/취소 완료" 같은 완료형 패턴을 우선으로 잡는다.
    const donePatterns = [
      "완료", "완료되었습니다", "완료됨",
      "처리되었습니다", "처리됨",
      "정상 처리", "정상처리",
      "확인되었습니다", "확인됨",
      "승인되었습니다", "승인됨",
      "접수되었습니다", "접수 완료", "접수완료",
      "취소되었습니다", "취소됨", "취소 완료", "취소완료",
      "결제되었습니다", "결제 완료", "결제완료",
      "발급되었습니다", "발급 완료", "발급완료"
    ];

    // "요청/신청/해야/바랍니다/확인해주세요" 같은 행동 요구가 같이 있으면 완료형이라도 재확인
    const actionCue = [
      "요청", "신청", "제출", "등록", "납부", "입금", "송금",
      "회신", "답장", "확인해", "확인해요", "확인해주세요", "바랍니다", "필요", "해야"
    ];

    const hasDone = hasAny(t, donePatterns);
    const hasAction = hasAny(t, actionCue);

    // 완료형 + 행동요구가 강하면 완료형으로 확정하지 않는다.
    return hasDone && !hasAction;
  }

  // 간단한 키워드 기반 분류(현 단계: 고정 구조 + 최소 오버피팅 방지)
  function decide(raw) {
    const t = normalize(raw);
    if (!t) {
      return {
        def: "입력이 비어 있습니다.",
        imp: "판단할 정보가 없습니다.",
        act: "이해 안 되는 문장을 그대로 1~2줄 붙여넣으세요."
      };
    }

    // 1) 완료/처리 알림(안심형)
    if (isCompletionNotice(t)) {
      // 기관/회사/금액/날짜만 가볍게 확인시키고 끝.
      return {
        def: "처리(완료/취소/확인) 결과를 알리는 안내일 가능성이 큽니다.",
        imp: "대부분 추가 조치가 필요 없습니다.",
        act: "날짜·금액·기관(회사)명만 확인하고, ‘추가로 무엇을 하라’는 문구가 없으면 그대로 두시면 됩니다."
      };
    }

    // 2) 금전/결제/납부/연체 계열 (행동 요구 가능성이 높음)
    const money = ["결제", "납부", "입금", "출금", "송금", "연체", "미납", "청구", "고지", "요금", "환불", "취소", "영수증", "현금영수증", "카드", "계좌"];
    const isMoney = hasAny(t, money) || /\d{1,3}(,\d{3})+\s*원|\d+\s*원/.test(t);

    if (isMoney) {
      return {
        def: "결제/납부/취소 등 금전 관련 안내일 가능성이 큽니다.",
        imp: "오해하면 손해로 이어질 수 있어 확인이 필요합니다.",
        act: "문장에 나온 날짜·금액·기관명을 먼저 확인하고, ‘무엇을 하라’는 문구(납부/링크/제출)가 있으면 그 문장까지 포함해 다시 붙여넣으세요."
      };
    }

    // 3) 링크/인증/보안
    const sec = ["인증", "본인", "비밀번호", "OTP", "인증번호", "로그인", "보안", "차단", "해킹", "접속"];
    if (hasAny(t, sec) || /https?:\/\//.test(t)) {
      return {
        def: "인증/보안/링크 관련 안내일 가능성이 있습니다.",
        imp: "피싱/사기 위험이 있을 수 있어 주의가 필요합니다.",
        act: "보낸 곳(기관/회사) 이름을 확인하고, 링크는 바로 누르지 말고 ‘무슨 이유로 보낸 건지’ 문장이 더 있으면 함께 붙여넣으세요."
      };
    }

    // 4) 기본(정보 부족)
    return {
      def: "의미가 확실하지 않은 문장입니다.",
      imp: "설불리 판단하면 손해/리스크가 생길 수 있습니다.",
      act: "발신처(기관/회사) 이름과 ‘무엇을 요구하는지’가 나오도록 앞뒤 문장 1~2줄을 더 붙여넣으세요."
    };
  }

  function render(res) {
    $out.textContent = `정의: ${res.def}\n\n중요도: ${res.imp}\n\n행동: ${res.act}`;
  }

  async function runText() {
    const raw = $text.value || "";
    const res = decide(raw);
    render(res);
    setState("DONE");
  }

  function resetAll() {
    $text.value = "";
    render({
      def: "입력이 비어 있습니다.",
      imp: "판단할 정보가 없습니다.",
      act: "이해 안 되는 문장을 그대로 1~2줄 붙여넣으세요."
    });
    setState("READY");
    $text.focus();
  }

  // 버튼 동작: READY면 바로답 / DONE이면 새 문장 넣기
  $go.addEventListener('click', async () => {
    if (state === "READY") {
      await runText();
    } else {
      resetAll();
    }
  });

  // 사진으로 바로답: confirm 없이 즉시 iOS 선택창 오픈
  $photo.addEventListener('click', () => {
    $img.click();
  });

  // 이미지 선택 시: 서버 OCR → textarea에 "덮어쓰기" (누적 금지)
  $img.addEventListener('change', async (e) => {
    const file = e.target.files && e.target.files[0];
    if (!file) return;

    // 사용자 혼란 방지: 이전 텍스트를 "덮어쓰기"로 초기화
    $text.value = "";

    const reader = new FileReader();
    reader.onload = async () => {
      try {
        const base64 = (reader.result || "").toString().split(",")[1] || "";
        const r = await fetch("/api/ocr", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ imageBase64: base64 })
        });
        const data = await r.json();

        if (!r.ok || !data || !data.text) {
          render({
            def: "글자를 읽지 못했습니다.",
            imp: "다시 촬영/선택이 필요합니다.",
            act: "글자가 크게 보이게, 흔들림 없이 다시 찍어주세요."
          });
          setState("DONE");
          return;
        }

        // ✅ OCR 결과는 누적 금지: 덮어쓰기
        $text.value = (data.text || "").trim();
        await runText();
      } catch (err) {
        render({
          def: "처리 중 오류가 발생했습니다.",
          imp: "일시적 오류일 수 있습니다.",
          act: "잠시 후 다시 시도해 주세요."
        });
        setState("DONE");
      }
    };
    reader.readAsDataURL(file);
  });
</script>
</body>
</html>
